---
title: "SingleMoleculeFootprinting"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    highlight: tango
vignette: >
  %\VignetteIndexEntry{SingleMoleculeFootprinting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  # comment = "#>", 
  tidy = F, 
  cache = F, 
  results = 'markup'
)
```

## Graphical things to fix

* Display messages outside code chunks
* 

## Introduction
*SingleMoleculeFootprinting* is a simple package providing convenience functions to analyze Single Molecule Footprinting (SMF) data. Following the workflow exemplified in this vignette, the user will be able to perform basic data analysis of SMF data with minimal coding effort. \

Starting from an aligned bam file, we show how to \

* perform quality controls over sequencing libraries
* extract methylation information at the single molecule level accounting for the two possible kind of SMF experiments (Single enzyme or double enzyme)
* classify single molecules based on their patterns of molecular occupancy
* plot SMF information at a given genomic location 

For compatibility with our analysis tools, we recommend the user to perform genomic alignments using the [`qAlign`](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign) function from QuasR as exemplified in **Our Paper** and the chuck below.
```{r, eval=F}
cl = makeCluster(40)
prj = QuasR::qAlign(sampleFile = Qinput,
              genome = "BSgenome.Mmusculus.UCSC.mm10",
              aligner = "Rbowtie",
              projectName = "prj", 
              paired = "fr",
              bisulfite = "undir", 
              alignmentParameter = "-e 70 -X 1000 -k 2 --best -strata",
              alignmentsDir = "./", 
              cacheDir = tempdir(),
              clObj = cl)
```


## Installation {.tabset}
### Developer installation
For develop installation, visit our [repository](https://github.com/Krebslabrep/SingleMoleculeFootprinting) on GitHub and copy link for cloning.
```{r, eval=F}
CLONING_LOCATION = "" # some arbitrary location (this is just where we'll clone the repo)
REPO_LINK = ""

system(paste0("cd ", CLONING_LOCATION))
system(paste0("git clone ", REPO_LINK))
devtools::install("SingleMoleculeFootprinting/")
```

### Bioconductor installation (NOT AVAILABLE YET)
For Bioconductor installation, visit our page on [Bioconductor]()
```{r, eval=F}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("SingleMoleculeFootprinting")
```

## Loading
```{r setup, message=F, eval=T}
library(BSgenome.Mmusculus.UCSC.mm10)
# library(SingleMoleculeFootprinting)
devtools::load_all()
```

## Define arguments
*SingleMoleculeFootprinting* inherits *QuasR*'s philosophy of working with pointer files. Briefly, a pointer file consists of a tab-delimited file with two or three fields, depending on whether the input data is in the unaligned paired-end format, the unaligned single-end or aligned format. For more details, please check the `qAlign` [documentation](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign). Here we show how our pointer file looks like.
```{r, eval=T}
Qinput = system.file("extdata", "QuasR_input_pairs.txt", package = "SingleMoleculeFootprinting", mustWork = T)
suppressMessages(readr::read_delim(Qinput, delim = "\t"))
```

## Library QCs
Before investing in a deep sequencing run for a SMF experiment, it is advisable to first perform a shallow sequencing run and to perform quality controls on the sequencing libraries.\

### QuasR QC report
It is always a good idea to produce a QC report after aligning. We can suggest the user to employ the [`qQCreport`](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qQCReport) function from *QuasR*.
```{r, eval=F}
qQCReport(Qinput, pdfFilename=NULL, chunkSize=1e6L, useSampleNames=FALSE, clObj=NULL)
```


### Bait capture efficiency
If SMF was performed on an large genome (e.g Mouse) you probably did some bait capture: here we check how efficient that process was by essentially computing the ratio of genomic alignments inside bait regions over the total ones.
```{r, eval=T}
BaitRegions = import(system.file("extdata", "mm10_baits.bed.gz", package = "SingleMoleculeFootprinting", mustWork = T), format="bed")
BaitCaptureEfficiency = BaitCapture(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, baits = BaitRegions)
```
In this case the capture efficiency equals to `r toString(BaitCaptureEfficiency)` because the example data was purposefully subsetted for an interesting region which falls entirely within baits. Under normal condition, one expects this value to be lower than 1: for the mouse genome for example we observe values around 0.7.

### Conversion rate precision
Here we ask how much of the observed Cytosine methylation falls in the expected contexts (*CpG* or *GpC*). Beware, this is a much slower computation than the above.
```{r, eval=T}
ConversionRateEstimate = ConversionRate(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, chr = 6)
```
For this sample, the observed conversion rate is `r toString(ConversionRateEstimate)`. This value happens to be slightly below the expected value of ~95

### Intersample correlation
Compare methylation fractions across samples. This gives a broad overview of whether the methylation pattern of a cell type or condition reflects what previously observed
```{r, eval=F}

```

## Analysis of single site (Amplicon data)
### Methylation extraction
Methylation values at the single molecule level can be extracted for the region of interest from aligned data using the `CallContextMethylation` function. \
Under the hood, the function performs the following operations: \

* Identification of the methylation status for the Cytosines in the genomic context relevant for the experiment (Single enzyme, double enzyme, etc.). The type of the experiment is inferred based on which user-provided substring is found in the SampleName field of the QuasR pointer file: \
```{r, echo = F}
knitr::kable(data.frame(ExperimentType = c("Single enzyme SMF", "Double enzyme SMF", "No enzyme (endogenous mCpG only)"), 
                        substring = c("\\_NO_", "\\_DE_", "\\_SS_"), 
                        RelevanContext = c("DGCHN & NWCGW", "GCH + HCG", "CG"), 
                        Notes = c("Methylation info is reported separately for each context", "Methylation information is aggregated across the contexts", "-")))
```

* Filtering reads based on conversion rate
* Strand collapsing
* Filtering Cytosines for coverage
```{r, eval=T}
MySample = suppressMessages(readr::read_delim(Qinput, delim = "\t")[[2]])
Region_of_interest = GRanges(seqnames = "chr6", ranges = IRanges(start = 88106000, end = 88106500), strand = "*")

Methylation = CallContextMethylation(sampleSheet = Qinput, 
                                     sample = MySample, 
                                     genome = BSgenome.Mmusculus.UCSC.mm10, 
                                     range = Region_of_interest, 
                                     coverage = 20, 
                                     ConvRate.thr = 0.2)
Methylation[[1]]
Methylation[[2]][1:10, 1:10]
```

```{r}
n = 1000
print(paste0("subsetting to ", n, " sampled reads to make vignette lighter. The user should skip this"))
readsSubset = sample(1:nrow(Methylation[[2]]), n)
Methylation[[2]] = Methylation[[2]][readsSubset,]
```


### Plotting single sites
Already at this stage it is possible to visually inspect results. To that end, we provide the functions `PlotAvgSMF` and `PlotSM` to plot respectively the average and single molecule SMF information at a given site. 
```{r, eval=T}
TFBSs = GenomicRanges::GRanges("chr6", IRanges(c(88106216, 88106253), c(88106226, 88106263)), strand = "-")
elementMetadata(TFBSs)$name = c("NRF1", "NRF1")
names(TFBSs) = c(paste0("TFBS_", c(4305215, 4305216)))

PlotAvgSMF(MethGR = Methylation[[1]], range = Region_of_interest, TFBSs = TFBSs)
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest)
```

Optionally, hierarchical clustering can be performed by setting the parameter `SortedReads = "HC"`. This can be useful to aggregate reads visually in order to spot PCR artifacts.
```{r, eval=T}
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = "HC")
```

### Single Molecule Sorting
Ultimately though, we want to classify reads based on their patterns of molecular occupancy. To that end we provide the functions `SortReadsBySingleTF` and `SortReadsByTFCluster` to classify reads based either on the occupancy patterns of one or multiple transcription factors. \

Under the hood, the classification is based on the definition of $n+2$ bins (with $n$ being the number of TFs). The n bins are each centered around one of the TFBSs of interest, while the 2 extra bins are located upstream and downstream of the two outmost TFBSs. For each read, the binary methylation status of the Cytosines contained in each bin is averaged to either a 0 or a 1 such that each read is eventually represented as sequence of n binary digits, for a total of $2^{(n+2)}$ possible sequences. \

Here, we show a usage case for the `SortReadsByTFCluster` function, as we have already identified the double binding of NRF1 at the genomic site under scrutiny. Usage and exploration of the output is identical for the other function, except for the the format of the *TFBSs* argument which should consist of a GRanges object of length 1 for `SortReadsBySingleTF` and of length $>$ 1 for `SortReadsByTFCluster.` 
```{r, eval=T}
SortedReads_TFCluster = SortReadsByTFCluster(MethSM = Methylation[[2]], TFBSs = TFBSs)
```

```{r, echo=F}
print(paste0("Number of retrieved states: ", as.character(length(SortedReads_TFCluster))))
print("States population:")
unlist(lapply(SortedReads_TFCluster, length))
```
N.b. non-populated states will are not returned. \

The output of each of these sorting functions can be passed directly as the `SortedReads` argument of the `PlotSM` function.
```{r}
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = SortedReads_TFCluster)
```

In order to be quantitative about these observations, the user can employ the `StateQuantificationPlot.` The function outputs a bar plot annotated with the percentage of reads found in each state. The function takes, as argument, the output of either of the two sorting functions.
```{r}
StateQuantificationPlot(SortedReads = SortedReads_TFCluster)
```

Finally, we provide the wrapper function `PlotSingleSiteSMF` to plot at once the three kinds of information detailed above and to export results as a pdf.
```{r, eval=F}
PlotSingleSiteSMF(ContextMethylation = Methylation, 
                  sample = MySample, 
                  range = Region_of_interest, 
                  SortedReads = SortedReads_TFCluster, 
                  TFBSs = TFBSs, 
                  saveAs = NULL)
```

--------
********

## Genome-wide analysis
Given the example data only cover one genomic region, we are going to restrict the following chunk to the interested chromosome only
This process can be quite lengthy and computationally demanding, it is advisable to run it on a cluster.
```{r, eval=F}
# Partition a genome by chromosome ("natural partitioning")
musmus_length=seqlengths(Mmusculus)[1:21] # change [1] to [1:21] to expand the analysis to the whole genome
tiles <- tileGenome(musmus_length, tilewidth=max(musmus_length),cut.last.tile.in.chrom=TRUE)

# Call the methylation genome wide for all Cs, loop/chromosome
# Cluster object for parallel processing of multiple samples
cluObj=makeCluster(length(SMFaln$SampleName))
lapply(1:length(tiles),function(i){

  print(i)
  
	meth_gr <- QuasR::qMeth(SMFproj, mode="allC", tiles[i], clObj=cluObj)
	contextMet=CallContextMethylation(meth_gr, cO, Mmusculus)
	saveRDS(contextMet, paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))

	})

# Filter away Cytosines with low coverage in all samples and combine chromosome-specific objects
AllCf=mclapply(1:length(tiles),function(i){

	contextMet=readRDS(paste(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
	CG=contextMet[[1]]
	GC=contextMet[[2]]
	AllC=c(CG,GC)
	met=elementMetadata(AllC)
	met2=met[,1:(ncol(met)-1)]
	cov.inx=!rowSums(is.na(met2))==ncol(met2)
	AllCf=AllC[cov.inx]
	AllCf

}, mc.cores=length(tiles))

AllC=unlist(GRangesList(AllCf))
AllC=sort(AllC)

# save final object
saveRDS(AllC, paste0(out_path,'/Context_methylation_call_',SMFproj@projectName,'.rds'))

# remove chromosome-wise temporary files
lapply(1:length(tiles), function(i){
  file.remove(paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
})
```

